export interface ErrorMessage<T> {
    key: keyof T;
    message: string;
}

type ValidationCallback<T, K extends keyof T> = (validator: Validator<T, K>) => void;

export class Validator<T, K extends keyof T> {
    private readonly item: T;
    private readonly labels: Record<K, string>;
    private readonly errors: ErrorMessage<T>[] = [];

    constructor(item: T, labels: Record<K, string>) {
        this.item = item;
        this.labels = labels;
    }

    static of<T, K extends keyof T>(item: T, labels: Record<K, string>) {
        return new Validator(item, labels);
    }

    getErrors() {
        return this.errors.slice();
    }

    run(fn: ValidationCallback<T, K>): Validator<T, K> {
        fn.call(this, this);
        return this;
    }

    when(condition: boolean | undefined | ValidationCallback<T, K>, callback: ValidationCallback<T, K>): Validator<T, K> {

        if (typeof condition === 'function') {
            // create another validator instance and run the condition function
            const errs = Validator.of(this.item, this.labels)
                .run(condition)
                .getErrors();
            
            // if there were errors generated by the condition function,
            // add them to our error list. Else, run the passed-in callback
            if (errs.length > 0) {
                errs.forEach(e => this.errors.push(e));
            } else {
                this.run(callback);
            }

        } else if (condition === true) {
            this.run(callback);
        }

        return this;
    }

    notEmpty(key: K): Validator<T, K> {
        if (!this.item[key]) {
            this.errors.push({ key, message: `${this.labels[key]} cannot be empty` });
        }
        return this;
    }

    numeric(key: K): Validator<T, K> {
        const v = this.item[key];
        const type = typeof v;
        
        if (type === 'string') {
            if (isNaN(+v!)) {
                this.errors.push({ key, message: `${this.labels[key]} must be numeric` });
            }
        } else if (type !== 'number' && type !== 'bigint') {
            this.errors.push({ key, message: `${this.labels[key]} must be numeric` });
        }
        
        return this;
    }

    greaterThanOrEq(key: K, min: number): Validator<T, K> {
        const v = this.item[key];
        const type = typeof v;
        if (type === 'number' || type === 'bigint') {
            if (+v! < min) {
                this.errors.push({ key, message: `${this.labels[key]} must be greater than or equal to ${min}` });
            }
        } else {
            this.errors.push({ key, message: `${this.labels[key]} is not a number` });
        }

        return this;
    }

    lessThanOrEq(key: K, max: number): Validator<T, K> {
        const v = this.item[key];
        const type = typeof v;
        if (type === 'number' || type === 'bigint') {
            if (+v! > max) {
                this.errors.push({ key, message: `${this.labels[key]} must be less than or equal to ${max}` });
            }
        } else {
            this.errors.push({ key, message: `${this.labels[key]} is not a number` });
        }

        return this;
    }
}